### 进程概念

- Linux的进程结构，一般分为三部分，**代码段、数据段(.data于.bss)和堆栈段**、代码段用于存放程序代码，还会存储一部分常量，如字符串常量字面值。数据段存放程序的全局变量和静态变量，堆栈段的栈用于函数调用，存放着函数的从参数、局部变量。

#### 程序如何转换为进程的？

一个程序的生成分成**四个阶段**：**预编译、编译、汇编和链接**，最后生成可执行文件。当程序执行时，**操作系统将可执行文件复制到内存中**，经过以下几个步骤转化为**进程**：

1. 内核将程序读入内存，为程序分配内存空间。
2. 内核为该进程分配**进程标识符（PID）**和其他所需资源。
3. 内核为进程保存PID及相应状态信息，并且将进程放入到队列中等待执行。
4. 由操作系统调度执行。

#### 进程的五种状态

**创建、就绪、执行、阻塞、终止**

<img src="F:\A_Sources\A笔记整理\计算机组成原理\微信截图_20220402092600.png" style="zoom:60%;" />

#### 进程创建方式

- **操作系统创建**：系统启动时，操作系统会创建一些进程，承担着管理和分配资源的任务，这些进程维持着系统的稳定运行，被称为**系统进程**
- 由**父进程创建**：常用函数**fork**

#### 守护进程

**守护进程**是运行在后台的一种生存期长的特殊进程。它独立于控制终端，处理一些协同级别的任务。

**创建过程**如下：

1. **创建子进程，父进程退出**

2. **调用setsid()创建一个新会话。**控制终端。登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，调用setsid使进程成为一个会话组组长，setsid调用成功后，进程成为新的会话组长和进程组长，并于原来的登录会话、进程组和控制终端脱离。

   **进程组**：是一个或多个进程的集合。

   **会话周期**：会话期是一个或多个进程组的集合

   **禁止进程重新打开控制终端**没经过以上步骤，进程已经是一个无终端的会话组长。

3. **将当前目录更改为根目录**。当前目录所在的文件系统不能卸载

4. **重设文件掩码**

5. **关闭不再需要的文件描述符**

#### 僵尸进程与孤儿进程

子进程退出后，由父进程调用`waitpid()或wait()`系统调用取得子进程的终止状态，然后回收子进程的资源。--->会出现**孤儿进程**和**僵尸进程**

**孤儿进程**：父进程退出后，子进程还在运行，子进程成为孤儿进程。孤儿进程被init进程（进程号1）收养，并且init进程对它完成收集工作。

**僵尸进程**：一个进程使用fork创建子进程，子进程退出后，父进程没有的调用wait()或waitpid()取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中占用系统资源——>被称为僵尸进程

- 如何解决僵尸进程

1. 即使使用wait系统调用；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD此你好的信号处理函数，再函数体中调用wait

2. 调用kill命令

   打开终端输入`$ ps aux | grep Z`，会列出进程表中所有僵尸进程的详细内容

   输入命令`$ kill -s SIGCHLD pid(父进程pid)`这样子进程退出后，父进程就收到信号了

   **或者** 可以强制杀死父进程 `$ kill -9 pid(父进程pid)` 父进程退出，紫禁城变成孤儿进程被init收养，init进程对它们进程状态收集工作。

   ## 进程通信
   
   #### 管道
   
   **管道的本质时一种文件**，一般的i/O函数都可以用于管道
   
   操作系统再内核中开辟一块缓冲区（称为**管道**）用于通信。管道是一种两个进程间**同一时刻**进行**单向通信**的机制——>半双工通信（ 同一时刻数据只能由一个进程流向另一个进程，一个负责读，一个负责写）
   
   管道分为**有名管道**和**无名管道**，无名管道只能用于具有亲缘关系的进程间通行。可以看作一种特殊的文件。命名管道可以允许无亲缘关系进程间的通信。
   
   **无名管道PIPE：**
   
   ```c
   #include <unistd.h>
   int pipe(int fd[2]);
   ```
   
   管道两端可以分别用描述子fd[0]和fd[1]来描述，管道两端的任务是固定的，即一段只能用于读(fd[0])，称为管道**读端**，另一端只能用于写(fd[1])，称为管道的**写端**。
   
   **有名管道FIFO**：
   
   FIFO本质也是一个文件，但是传递方向可以是**双向**的。与PIPE最大的差别在于FIFO再文件系统中拥有一个名称，打开方式与普通文件一样（使用open）这样就可以用于非相关的进程间通信。
   
   ```C
   int mkfifo(const char * filename,mode_t mode);
   int open(const char * pathname,int oflag);
   //oflag参数可选 O_RDONLY,O_WRONLY,O_NOBLOCK
   /*
   O_RDONLY以只读打开方式打开一个管道文件，同时进程将阻塞，直到有一个进程以只写的方式打开管道文件
   O_RDONLY | O_NOBLOCK: 只读打开，进程不阻塞
   O_WRONLY ---->一样
   */
   ```
   
   ### 系统IPC
   
   ——**消息队列、共享内存、信号量、信号**
   
   **信号**是linux进程间通信唯一的异步通讯方式。**信号从软件层次上看是对中断机制的一次模拟，一个进程收到信号时的处理方式与CPU收到中断时的处理方式一样，收到信号的进程会跳入信号处理函数，执行完之后再跳回原来的位置继续执行**

| 通信方式                    | 简介                                                         | 优点                                                         | 缺点                                                         |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 无名管道（ pipe ）          | 管道是一种半双工的通信方式                                   | 进程的亲缘关系通常是指父子进程关系。使用方便快捷（优点）。   | 管道是一种半双工的通信方式，数据**只能**单向流动，而且只能在具有**亲缘关系**的进程间使用（缺点） |
| 有名管道 （named pipe）     | 有名也是半双工的通信方式                                     | **允许**无亲缘关系进程间的通信（优点）。                     |                                                              |
| 消息队列（ message queue ） | 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。 | 消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点（优点）。 | 开销大（缺点）                                               |
| 信号量（ semophore ）       | 信号量是一个计数器，可以用来控制多个进程对共享资源的访问     | 它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 |                                                              |
| 信号（ sinal ）             | 信号是一种比较复杂的通信方式（缺点），用于通知接收进程某个事件已经发生。 | 快捷、准确                                                   |                                                              |
| 共享内存（ shared memory ） | 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。 | 共享内存是最快的 IPC 方式（优点），它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 | 缺点是开销大，创建额外的内存。                               |
| 套接字（ socket ）          | socket套接字则可以实现多机通信。套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程 | 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信（优点） | 开销大，需要一整套的接口函数。                               |

