## 预处理和关键字

- **关键字sizeof的作用是什么，函数strlen()呢？**

  1.sizeof关键字用来计算变量、数据类型所占内存的字节数。sizeof(数组名)得到数组所占字节数，sizeof(字符串指针名)得到指针所占字节数。

  **Tips**：

  char str[] = "abcde"; 定义了一个字符数组，最终结果char str[4] = {'a','b','c','d','e',\0'} 是一个局部变量

  char * ptr = "abcde" 把“abc“赋值给一个字符指针变量，定义的是一个普通指针，没有定义空间存放"abcde",编译器帮我们找地方存放”abcde”，这里把”abcde“当作常量并把它放到程序的常量区是编译器最合适的选择。

  ——-->sizeof(str) = 6 因为str的类型是char[7] ；而sizeof(ptr) =4 因为ptr类型是char * 指针

  2.而strlen()函数则用来测试字符串所占字节数，不包括结束字符 ’\0’。strlen(字符数组名)得到字符串所占字节数，strlen(字符串指针名)得到字符串所占字节数。

- **关键字extern的作用是什么？**

  用于跨文件引用全局变量，即在本文件中引用一个已经在其他文件中定义的全局变量

- **关键字auto的作用是什么？**

  用来定义自动局部变量，自动局部变量在进入声明该变量的语句块时被建立，退出语句块时被注销，仅在语句块内部使用

- **关键字rigister的作用是什么**

  作用：编译器会将register修饰的变量尽可能地放在CPU的寄存器中，以加快其存取速度，一般用于频繁使用的变量

  注意：register变量可能不存放在内存中，所以不能用&来获取该变量的地址；只有局部变量和形参可以作为register变量；寄存器数量有限，不能定义过多register变量。

- **C语言编译过程中，关键字volatile和extern分别在哪个阶段起作用？**

  volatile在编译阶段，extern在链接阶段。C语言编译过程分为预处理、编译、汇编、链接。

- **关键字static的作用是什么？**

  static修饰局部变量时：①改变了其存储位置，存储在静态区；②同时改变了其生命周期，为整个源程序，因此它只被初始化一次，若没显式初始化则自动初始化为0。 

  static修饰全局变量时：改变了其作用域，只可以被文件内所用函数访问。

  static修饰函数时：改变了其作用域，只可被这一文件内的其它函数调用。

- **关键字const的作用**

  <img src="F:\A_Sources\A笔记整理\图片\const.png" style="zoom:150%;" />

----

**数组指针 指针数组 函数指针 函数指针数组** ——>Edge浏览器收藏

- 数组名只是==数组元素的首地址==（平时为了方便，省略了“首”），它和数组名取地址的结果相同，都指向同一个地方，但却不是相同的类型（arr --->int [3],&arr---> int [3]*)
- 指向数组第一个元素的那个指针仅代表数组的第一个元素（p <==> &arr[0]）

---

## 数据类型

1. 用变量a给出下面的定义

   - 一个整型数：`int a `
   - 一个指向整型数的指针：`int *a`
   - 一个指向指针的指针，它指向的指针是指向一个整型数的指针（二重指针）：`int **a`
   - 一个有10个整型数的数组：`int a[10]`
   - 一个有10个指针的数组，这10个指针是指向整型数的（指针数组）：`int *a[10]`
   - 一个指向有10个整型数数组的指针（数组指针):`int (*a)[10]`
   - 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（函数指针）：`int (*a)(int)`
   - 一个有10个指针的数组，这10个指针均指向函数，该函数有一个整型参数并返回一个整型数（函数指针数组）：`int (* a[10])(int)`

2. 下面代码输出什么？

   ```c
   void foo(void){
       usigned int a = 6;
       int b  = -20;
       (a + b > 6)?printf(">6"):printf(" <= 6")
   }
   ```

   输出是">6"，当运算表达式中存在有符号数和无符号数时，有符号数隐形转换成无符号数（底层补码不变，此时从符号数变成无符号数）正数补码不变，负数补码是其反码+1，-20变成了一个很大的数，所以结果大于6

3. ==字串常量不可以修改==

   ```c
   #incldue <stdio.h>
   void main(){
       char * s = "AAA";
       s[0] = 'B';
       printf("%s",s);
   }
   ```

   "AAA"是字符串常量，s是指针，指向这个字符串常量，s声明时候就有问题，应该是`cosnt char * s = "AAA"`

   因为"AAA"是字符串常量，所以对s[0]的赋值操作是不允许的

4. 结构体内存对齐

   ——>元素是按照定义顺序一个一个放到内存中，而并不是紧密排列的，从结构体存贮的首地址开始，每个元素放置到内存中时，它都会认为是按照自己的大小开划分的，因此元素放置的位置一定会在自己宽度的整数倍上的。

   (1)内存对齐大大提升内存访问速度，是一种以空间换时间的方法

   (2)对于平台的移植，有些CPU遇到未对齐的边界直接罢工

   ==结构体的内存对齐==

   - 有`#parama pack`宏的情况下

     有宏定义的情况下 结构体的自身宽度就是宏上规定的数值大小 所有内存都按照这个宽度去布局

     #parama pack参数只能是'1','2','4','8','16'

   - 没有`#parama  pack`宏定义的情况下

     没有宏定义的情况下 结构体宽度由最大成员属性的宽度决定

   ***内存对齐原则：***

   I.第一个成员的首地址位0；

   II.每个成员的首地址是自身大小的整数倍

   III.结构体的总大小，为其成员中所含最大类型的整数倍

5. 数组首元素地址和数组地址的异同？

   - 异：数组首元素地址和数组地址是两个不同的概念，例如int a[10]，a的值是数组首元素的地址，那么a+1就是第二个元素的地址，int类型占用4个字节，所以两者相差4。而&a是数组的地址，所以&a+1就是向后移动（10*4）个单位，两者相差40
   - 同：数组首元素地址和数组地址的值是相等的

6. 结构体struct和联合体union的区别：

   - 两者最大的区别在于内存的使用。

   - 结构体各成员拥有自己的内存，各自使用且互不干涉，遵循内存对齐原则。

   - 联合体所有成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权。一个联合体变量的总长度应至少能容纳最大的成员变量，且需要进行内存补齐。

7. C语言中不同数据类型的赋值规则

   （1）整数与整数之间（char, short, int, long）：

   ①长度相等：内存中的数据不变，只是按不同的编码格式来解析。

   ②长赋值给短：截取低位，然后按短整数的数据类型解析。

   ③短赋值给长：如果都是无符号数，短整数高位补0；如果都是有符号数，短整数高位补符号数；如果一个有符号一个无符号，那么先将短整数进行位数扩展，过程中保持数据不变，然后按照长整数的数据类型解析数据。

   （2）整数与浮点数之间

   ①浮点数转整数：截取整数部分。

   ②整数转浮点数：小数部分为0，整数部分与整数相等。

   （3）float与double之间

   ①double转float会丢失精度。

   ②float转double不会丢失精度。

   **Tips：**

   ​		整数在内存中都是以补码的形式存储的
   
   ---
   
   ## 内存管理与编程题
   
   1. 由gcc编译的C语言程序占用内存分为哪几个部分？
   
      | 栈区（stack）            | 存放函数的参数、局部变量                                     |
      | ------------------------ | ------------------------------------------------------------ |
      | 堆（heap）               | 提供程序员动态申请的内存空间                                 |
      | 全局（静态）区（static） | 存放全局变量和静态变量，初始化不为0的全局变量和静态变量、const型常量在一块区域(.data段)；未初始化的、初始化为0的全局变量和静态变量在相邻的另一块区域(.bss段) |
      | 程序代码区               | 存放函数体的二进制代码和字符串常量                           |
   
   2. 大小端模式
   
      大端：一个数据的低位字节数据存储在低地址
   
      小端：一个数据的高位字节数据存储在低地址
   
      例如`int a = 0x12345678 //a的首地址是0x200` 大端模式：
   
      | 0x12  | 0x34  | 0x56  | 0x78  |
      | ----- | ----- | ----- | ----- |
      | 0x200 | 0x201 | 0x202 | 0x203 |
   
      判断一个系统的大小端存储模式：
   
      ```c
      /*
      int强制类型转换为char *，用[]或者 * 进行解引用
      */
      void checkCPUMode(void){
          int c = 0x12345678;
          char *p = (char *)&c;
      	if (p[0] == 0x12)
              printf("big endian\n");
          else if(p[0] = 0x78)
              printf("samll endian\n");
          else
              prinitf("Uncertain\n");
      }
      /*
      包含shart和union的共用体
      */
       void checkCPUMode(){
           union Data{
               short a;
               char b[sizeof(short)];
           }data;
           data.a = 0x1234;
           
           if(data.b[0] == 0x12)
               printf("Big endian\n");
           else if(data.b[0] == 0x34)
               printf("Small endian\n");
           else
               printf("Uncertain\n");
       }
      ```
   
   3. 全局变量和局部变量的区别？
   
      - 全局变量存储在静态区，进入main函数前就被创建，生命周期是整个源程序
      - 局部变量在栈中分配，在函数调用时才被创建，在函数退出时销毁，生命周期为函数内。
   
   4. 以下程序中，主函数能否申请到内存空间？
   
      ```C
      #include <stdio.h>
      #include <stdlib.h>
      #include <string.h>
      void getmemory(char *p){
          p = (char *)malloc(100);
          strcpy(p."Hello World");
      }
      int main(){
          char *str = NULL;
          getmemory(str);
          printf("%s\n",str);
          free(str);
          return 0;
      }
      ```
   
      不能成功申请到内存。getmemory(str)没能改变str的值，因为传递给子函数的只是str的复制值NULL，main函数中的str一直都是NULL
   
      ```C
      //传递二重指针
      void getmemory(char **p){
          *p = (char *)malloc(100);
          strcpy(*p,"hello world");
      }
      ```
   
   5. 下面运行Test（）会有什么结果
   
      ```c
      void Test(){
          char *str = (char * )malloc(100);
          strcpy(str,"hello");
          free(str);
          if(str != NULL){
              strcpy(str,"world");
              printf("%s\n",str);
          }
      }
      ```
   
      篡改堆区的野指针指向的内容，后果难以预料。
   
      - free(str)之后，str成为野指针，没有设置为NULL，if(str != NULL)并没有执行
   
      - 野指针不是NULL指针，是指向被释放的或者访问受限的内存的指针
   
      - 造成野指针的原因：
   
        1.指针变量没有被初始化，任何刚创建的指针不会自动变成NULL；
   
        2.指针被delete或者free后，没有置为NULL；
   
        3.指针操作超越了变量的作用的范围，比如要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。
   
   6. memcpy和memmove一样吗？
   
      mencpy() menmove()都是用来拷贝scr所指向内存内容n字节到dest所指的地址上
   
      当scr和dest所指的区域重叠时，memcpy可能无法正确处理，儿memmove仍然可以。
   
      - memcpy无论什么时候都是从前往后拷贝，当源地址在前，目标地址在后，且两个区域有重叠的时候会造成拷贝错误，达不到理想的效果
   
        ```c
        void * memcpy(coid *dest,const void * src,size_t count){
            if(dest == NULL || src == NULL || conut <= 0)
                return NULL;
            char *d = (char *)dest;
            char *s = (char *)src;
            while(count --){
                *d++ = *s++;
            }
            return dest;    
        }
        ```
   
      - memmove则分两种情况，目标地址在前，源地址在后，从前往后拷贝内容。源地址在前，目标地址在后，从后往前拷贝内容。
   
        ```c
        void * mommove(void *dest,const void *src,size_t count){
            if(dest == NULL || src ==NULL || count <= 0)
                return NULL;
            if (dest < src){
                char *d = (char *)dest;
                char *s = (char *)src;
                while(count --){
                    *d++ = *s ++
                }
            }
            else{
                char *d = (char *)dest + count;
                char *s = (char *)src + count;
                while(count --){
                    *d-- = *s --
                }
            }
        }
        ```
   
   7. malloc的底层实现
   
      - malloc函数的底层实现是操作系统有一个由可用内存块连接成的空闲链表。调用malloc时，它将遍历该链表寻找足够大的内存空间，将该块一分为二（一块与用户申请的大小相等，另一块为剩下来的碎片，会返回链表），调用free函数时，内存块重新连接回链表
      - 若内存块过于琐碎无法满足用户需求，则操作系统会合并相邻的内存块。 
   
   8. 内存泄露是什么？
   
      (Memory lead)程序中已动态分配的堆内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢，甚至系统崩溃等严重后果。
   
   9. 内存溢出是什么？与内存泄露有何关系?
   
      (Out of Memory)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于宇通能提供的最大内存，此时程序无法运行，系统提示内存溢出，有时候会自动关闭软件。
   
      **造成内存溢出的原因：**
   
      1.内存泄露的堆积最终导致内存溢出
   
      2.需要保存多个耗用内存过大的对象或加载单个超大的对象时，其大小超过了当前剩余的可用内存空间
   
   10. 堆栈溢出一般是什么原因导致的？
   
       - 堆栈溢出一般包括堆内存溢出和栈内存溢出，两者都属于缓冲区溢出
       - 堆内存溢出可能是堆的尺寸设置得过小/动态申请的内存没有释放
       - 栈内存溢出可能是栈的尺寸设置得过小/递归层次太深/函数调用层次过深/分配了过大的局部变量
   
   11. 内存溢出和内存越界的区别？
   
       - 内存溢出：要求分配的内存超出了系统所能给予的，于是产生溢出。
       - 内存越界：向系统申请了一块内存，而在使用时超出了申请的范围，常见的是数组访问越界。

​	