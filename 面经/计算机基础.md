#### - 什么是系统调用

Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用；用户可以通过系统调用的命令在自己的应用程序中调用他们，从某种角度看，系统调用和普通函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于内核态；而普通函数使用函数库或者用户自己提供，运行于用户态

#### - 并发与并行

同一时刻单个CPU只能处理一个任务，但不停地在多个任务来回快速切换，这就是**并发**。**并发**的"同时"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象                       

所以一个多核CPU可以同时处理多个任务，这就是**并行**。**并行**的"同时"是同一时刻可以多个任务在运行(处于running)

#### 存储器

- 顶层寄存器——存取速度块，容量小，成本高
- 高速缓存 cache——多数操作系统在缓存中保留频繁使用的文件的一部分，以避免从磁盘中重复地调取这些文件，主要就是为了提升访问速度
- 主存——随机访问存储器RAM，**常说的内存**。所有不能再高速缓存中得到满足的访问请求都会转往主存
- 硬盘（磁盘）——成本低，容量大，访问速度慢，扇区是磁盘中最小的存储单位

**固态硬盘不是磁盘，固态硬盘不是机械结构，数据是存储再存储器（内存）中的**

#### - I/O设备

I/O设备包括：设备控制器和设备本身

**控制器的任务是为操作系统提供一个简单的接口**，而不同的设备的控制器是不同的，需要不同的软件进行控制。

专门与控制器对话，发出命令并接受响应的软件，称为设备驱动程序。设备驱动程序会装入操作系统中，在**内核态**运行

- 一个驱动程序就是一个函数和数据结构的集合，**它的目的是建立内核和实际硬件之间的连接，从而提供通过内核访问底层硬件的上层API接口**。内核用这个接口请求驱动程序控制设备的I/O操作

实现输入和输出的方式有三种：

==***1.查询模式***==

用户程序发出一个系统调用，设备驱动程序启I/O并在一个**循环中不断查询**该设备，看设备是否完成了工作、当I/O结束后，设备驱动程序把数据送到指定的地址，然后操作系统将控制返回给调用者

缺点一直占据CPU，CPU一直轮询设备知道对应的I/O操作完成，效率不高

==***2.中断模式***==

设备驱动程序启动设备并让该设备在操作完成时产生一个**中断**

- 中断是指当出现需要时，CPU暂停当前进程的执行，转而执行处理新情况的中断处理程序。当执行完中断处理程序后，再重新从刚才停下的位置继续执行当前的进程。

- 为了区分不同的中断，每个设备都有自己的中断号，系统中有0-255一共256个中断，系统有一张中断向量表，存放256个中断的中断服务程序的入口地址，每一个入口地址对应一段代码，即中断服务函数。

- ARM的七种模式

  ![image-20220401120732696](C:\Users\WwwwYI\AppData\Roaming\Typora\typora-user-images\image-20220401120732696.png)

ARM系统包括两类中断，一类是**IRQ中断**，另一类是**FIQ**中断，IRQ是普通中断，FIQ是快速中断，在进行大批量的复制，数据传输等工作时，常使用FIQ中断。FIQ中断的优先级高于IRQ。

**IRQ中断和FIQ中断都属于ARM的异常模式**。在ARM系统中，一旦有中断发生，不管是外部中断还是内部中断，正在执行的程序都会停下来，通常按照一下步骤处理中断：

(1)**保存现场**，保存当前的PC到R14，寄存器R14常用作**链接寄存器**（LR，Link Register），当进入中断程序时，常来保存PC（program counter，程序计数器)的返回值，保存PC值后，接着保存当前的程序运行状态到SPSR（Storage Program Status Register，程序状态备份寄存器)

(2)**模式切换，**根据发生中断的类型，进入IRQ模式或者FIQ模式

(3)**获取中断源，**以异常向量表保存在低地址为例，若是IRQ中断，则PC指针跳到0X18处(`0X18: LDR  PC, IRQ_ADDR`);若是FIQ中断，则跳到0x1C处(`0x1c: LDR PC, FIQ_ADDR`)，IRQ和FIQ的异常向量地址一般保存的是中断服务子程序的地址，所以接下来PC指针跳入中断服务子程序处理中断。

(4)**中断处理**

(5)**中断返回，恢复现场，**完成中断服务子程序后，将SPSR中保存的程序运行状态恢复到CPSR(Current Program Status Register，当前程序状态寄存器)，R14中保存的被中断程序的地址恢复到PC中，继续执行被中断的程序

![](E:\A_SRC\A笔记整理\计算机组成原理\中断程序运行过程.png)

***用户模式user***和***supervisor模式***有什么区别：

**User用户模式**是用户程序的工作模式，它运行在操作系统的用户态，他没有权限去操作硬件，只能执行处理自己的数据，也不能切换到其他模式下，想要访问硬件资源或者切换到其他模式只能通过**软中断**或者产生**异常**

**Supervisor管理模式**是CPU上电后的默认模式，在该模式下做系统的初始化，软中断处理也在该模式下。用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式，相比IRQ和FIQ通过硬件出发，Supervisor优先级最低，而且是通过**软件**触发。

==***3.DMA模式***==

I/0通过一种特殊的直接存储器访问（Direct Memory Access，DMA）芯片，可以直接控制外围设备的数据流，而无需持续的CPU干预。这样效率很高，但成本也会相对较高，DMA是由专门的硬件（DMA）控制。

DMA传送**主要用于需要告诉大批量数据传送的系统中，议题该数据的吞吐量，如磁盘读取、图像处理、高速数据采集系统、同步通信中收/发信号等**应用广泛。

### 🐎MAKFILE：

更好的管理项目的的代码编译，节约编译时间（没改动的文件不编译）

```makefile
目标...: 依赖...
	命令1
	命令2
	...
```

1. **目标**：即要**生成的文件**，如果目标文件的更新时间晚于依赖文件的更新时间，则说明依赖文件没有改动，目标文件不需要重新编译。否则重新编译并更新目标。

2. **依赖：**即目标文件由**哪些文件生成**。如果依赖条件中存在不存在的依赖条件，则会寻找其它规则是否可以产生依赖条件。

3. **命令**：即通过执行该命令，由依赖文件生成目标文件。

   注意每条命令前必须有且仅有一个 tab 保持缩进，这是语法要求。

4. **ALL**：Makefile 文件默认只生成第一个目标文件即完成编译，但是我们可以通过 “ALL” 指定需要生成的目标文件。

### 软中断

Linux将中断处理分成两个阶段，也就是**上半部和下半部**：

- **上半部用来快速处理中断**，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作（硬中断）
- **下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行**（软中断）

比如：网卡接收到数据包后，会通过**硬件中断**的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。

- 对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了），最后再发送一个**软中断**信号，通知下半部做进一步的处理。
- 而下半部被**软中断信号**唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

上半部直接处理硬件请求，也就是我们常说的**硬中断**，特点是快速执行。

下半部则是由内核触发，也就是我们常说的**软中断**，特点是延迟执行。