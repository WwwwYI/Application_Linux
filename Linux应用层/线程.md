## 线程

### 线程与进程

- **进程是资源管理的最小单位，**那么每个进程都拥有自己的代码段、数据段和堆栈段。造成进程再进行切换的时候都需要有比较复杂的上下文切换动作——因为要保存当前进程上下文的内容，还要恢复另一个进程的上下文；在进程却换上下文时，需要重新映射虚拟地址空间，进出OS内核、寄存器切换

为了进一步减少CPU在进程切换时的额外开销，Linux演化出了另一个概念——线程

- **线程是程序执行的最小单位**。Linux中线程也被称为轻量级进程，一个进程至少需要一个线程作为它的指令执行体，进程管理着资源（CPU、内存、文件等）将线程分配到某个CPU上执行。一个进程可以拥有多个线程，可以使用多个cpu来执行各个线程，以达到最大并行，提高工作效率；

**线程的本质是一个进程内部的一个控制序列，它是进程里面的东西，一个进程可以拥有多个线程**

- linux系统中每个进程都有独立的地址空间，一个进程崩溃后，并不会对其他进程造成影像。而线程是进程内部的一个控制序列，进程崩溃后线程也会随之崩溃。——一个多进程的程序会比多线程的程序健壮。
  - 一个程序至少有一个进程，一个进程至少有一个线程
  - 线程使用的是进程的资源，进程崩溃线程也随之崩溃
  - 线程的上下文切换，要比进程更加快速。本质上线程的很多资源都是共享进程的，所以切换时，需要保存的切换的项比较少

### POSIX 可移植操作系统接口

可移植操作系统接口(Protable Operating System Interface)——如果应用程序使用POSIX标准接口来调用系统函数，那么应用程序将非常容易到遵循POSIX标准的系统上

### pthread_create()创建线程

`int pthread_create(pthread_t*thread,const pthread_attr_t_t *attr,`

`										void *(*start_routine)(void *),void *arg);`

- thread: 指向线程标识符的指针
- attr：设置线程属性，一般NULL
- start_routine: 是一个函数指针，只想要运行的线程的入口，及线程运行时要执行的函数代码
- arg：运行线程时传入的参数
- *return*：成功——>0，失败——>EOF，返回对应的错误代码！

***ATTENTION***

因为pthread并非Linux系统的默认库，而是POSIX线程库，函数在执行错误时的错误信息作为返回值返回，并不会修改系统全局变量errno，淡然也无法使用perror()打印错误信息

###### 线程的分离状态

在任何一个时间点上，线城市可结合的(joinable)或者是分离的(ditached)。一个可结合的线程能够被其他线程回收资源和杀死，在被其他线程回收之前，它的存储器资源（如栈）是不释放的。相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。

- 线程的分离状态决定一个线程以什么样的方式终止自己

- 进程中的线程可以调用`pthread_join()`函数来等待某个线程的终止，获得该线程的终止状态，并回收所长用的资源，如果对线程的状态不感兴趣，可以将rval_ptr设置为NULL

  `int pthread_join(pthread_t tid,void **rval_ptr);`

- 线程可以调用`othread_detach()`函数将此线程设置为分离状态，设置为分离状态的线程在线程结束时，操作系统会自动收回它占用的资源。设置为分离状态的进程，不能再调用`pthread_join()`

​		`int pthread(pthread_t pid);`

#### 线程的调度策略

- 分时调度策略，SCHED_OTHER。这是线程属性的默认值，另外两种调度方式只能用于以超级用户权限运行的进程
- 实时调度策略，先进先出方式调度(SCHED_FIFO)。先进入队列的线程能优先得到运行，线程会一直占用CPU，直到有更高优先级任务到达或自己主动放弃CPU使用权
- **实时调度策略 ，时间片轮转方式调度(SCHED_RR)。**不同的是前者的每个线程都有一个执行时间配额， 当采用SHCED_RR策略的线程的时间片用完，系统将重新分配时间片， 并将该线程置于就绪队列尾，并且切换线程，放在队列尾保证了所有具有相同优先级的RR线程的调度公平。

### 线程退出 pthread_exit()

- 隐式退出：在线程创建后，系统就开始运行相关的线程函数，在该函数运行完之后，该线程也就退出了， 这是线程的一种隐式退出的方法；
- 显式退出：另一种退出线程的方法是使用pthread_exit()函数，让线程显式退出，这是线程的主动行为

**ATTENTION**

使用线程函数时，不能随意使用exit()退出函数来进行出错处理， 这是因为exit()函数的作用是使调用进程终止，而一个进程往往包含多个线程，因此，在使用exit()之后， 该进程中的所有线程都会被退出。

`void pthread_exit(void *retval);`

- retval：如果retval不为空，则会将线程的退出值保存到retval中，如果不关心线程的退出值，形参为NULL即可。

- 如果某个线程想等待另一个线程退出，并且获取它的退出值，可以使用pthread_join()函数，以阻塞的方式等待thread指定的线程结束，此函数返回时，等待线程的资源将会被回收，如果线程已经结束，那么函数立刻返回。

​		**并且线程必须是可结合的状态**。因此为了避免内存泄漏， 所有线程的终止时，要么已被设为DETACHED，要么使用pthread_join()来回收资源。

