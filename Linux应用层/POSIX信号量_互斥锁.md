## POSIX信号量

信号量（Semaphore）是一种实现进程/线程间通信的机制，可以实现线程/进程之间同步或临界资源的互斥访问，常用于协助一组互相竞争的线程/进程来访问灵界资源。在多线程/进程的系统中，各进程/线程之间需要同步或者互斥实现临界资源的保护。

- 无名信号量：直接保存在内存中。无名信号量没有名字，只能存在于内存中，要求使用信号量的进程、线程必须能访问无名信号量所在的这一块内存，所以无名信号量只能应用在同一进程内的线程之间的同步或者互斥。
- 有名信号量：要求创建一个文件，可以通过名字访问，可以被任何知道它们名字的进程或者线程使用。

单个进程中使用POSIX信号量时，无名信号量更简单，多个进程间使用POSIX信号量时，又名信号量更简单

**互斥关系：**

在不同的进程、线程之间，为了争夺有限的系统资源（硬件或者软件资源）会进入竞争状态。

为了防止多个程序访问同一个共享资源而引发的一系列问题，在任意时刻

**同步关系：**

在多进程/多进程/线程操作系统环境下，多个进程/线程会同时运行，并且一些进程/线程之间可能存在一定的关联。

多个进程/线程可能为了完成同一个进程/线程会相互协作，这样形成进程/线程之间的同步关系。



**临界区**指执行数据更新的代码需要独占式地执行，信号量提供这样一种访问机制，让一个临界区同一时间只有一个进程/线程再访问它，信号量可以用来协调线程/进程对共享资源的访问。

---

## 互斥锁

当互斥锁被线程锁有时，该互斥锁处于闭锁状态，线程获得互斥锁的所有权。当该线程释放互斥锁时，该互斥锁处于开锁状态，县城失去该互斥锁的所有权。

同时只有一个线程能获得互斥锁，**特别的**，持有该互斥锁的线程能够再次获得这个互斥锁而不被阻塞，这就是互斥锁的**递归访问**。这个特性与一般的信号量有很大的不同，在信号量中，由于会不存在可用的信号量，线程递归获取信号量时会发生阻塞，最终形成*死锁*。

***死锁：***

1.自己把自己阻塞了；

2.两个线程相互阻塞。

***避免死锁：***

- 对共享资源操作前一定要获得锁；
- 完成操作后一定要释放锁。
- 尽可能短的时间占用所
- 如果有多个锁，如果获得的顺序是ABC连环扣，那么释放顺序也应该是ABC

***适用场景***

- 保护临界资源
- 线程可能会多次获取互斥锁的情况下。这样可以避免用以线程多次递归持有而造成死锁的问题

---

使用互斥锁处理不同线程对临界资源的同步时，线程想要获得互斥锁才能访问资源，如果一旦有线程成功获得了互斥锁，色泽互斥锁立即变成闭锁状态，此时其他线程会因为获取不到互斥锁儿不能访问该资源，那么此时线程有两个选择：扭头就走，不进行等待；或者一直阻塞在这里等待，知道互斥锁被持有线程释放后，线程才能获取互斥锁从而访问该临界资源，此时互斥锁再次上锁，如此一来就可以确保同一时刻只有一个线程正在访问这个临界资源，保证了临界资源的安全性。

### 静态互斥锁

- `pthread_mutex_t fastmutex = PTHREAD_MUTEX_INITIALIZER;`
- `pthread_mutex_t recmutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;`
- `pthread_mutex_t errchkmutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;` - - - 
  - PTHREAD_MUTEX_INITIALIZER：表示默认的互斥锁，即快速互斥锁。互斥锁被线程1持有时，此时互斥锁处于闭锁状态， 当线程2尝试获取互斥锁，那么线程2将会阻塞直至持有互斥锁的线程1解锁为止。- 
  - PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP：递归互斥锁。互斥锁被线程1持有时，线程2尝试获取互斥锁， 将无法获取成功，并且阻塞等待，而如果是线程1尝试再次获取互斥锁时，将获取成功，并且持有互斥锁的次数加1。
  - PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP：检错互斥锁。这是快速互斥锁的非阻塞版本，它会立即返回一个错误代码（线程不会阻塞）。

### 动态互斥锁初始化 pthread_mutex_init()

`int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutexattr_t *mutexattr);`

### 获取锁 释放锁

`int pthread_mutex_lock(pthread_mutex_t *mutex);`

`int pthread_mutex_trylock(pthread_mutex_t *mutex);`(lock的非阻塞版本)

`int pthread_mutex_unlock(pthread_mutex_t *mutex);`

### 互斥锁使用流程

- 线程获取互斥锁
- 然后访问共享资源
- 最后释放互斥锁

### 销毁锁 pthread_mutex_destory()

`int pthread_mutex_destory(pthread_mutex_t *mutex);`
