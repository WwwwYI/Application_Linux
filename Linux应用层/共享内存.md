## 共享内存

- 允许多个不想关的进程访问同一个逻辑内存，直接将一块裸露的内存放在需要数据传输的进程面前。因此，供词昂内存是效率最高的一种IPC通信机制

- 进程间需要共享的诗句被放在共享内存区域，所有需要访问该共享区的进程都要把该共享区映射到本进程的地址空间里

- 共享内存属于临界资源，在某一时刻最多只能有一个进程对其操作（读/写），一般配合信号量，互斥锁等协调机制

- 进程与进程之间的虚拟内存空间本来相互独立，不能互相访问，但是可以通过某些方式 ，使得相同的一块污泥内存多次映射到不同的进程的虚拟空间中；进程1像共享内存写入数据后，共享内存的数据就变化了，那么进程2就能立即读取到变化了的数据，中间未经过内核的拷贝，因此效率极高

  - 注：这是因为父子进程运行在完全独立的虚拟地址空间中，父子进程中的变量指向相同，

    *但是在MMU和操作系统的共同操纵（虚拟地址映射）下，*

    *父进程的buffer和子进程的buffer指向的是不同的物理内存地址。*

    *所以，子进程可以复用父进程的变量资源，而不用担心受到父进程的影响，因为自己拿到的是副本*

## 共享内存的特点

- 是进程间通信中效率最高的方式之一
- 共享内存是系统出于多个进程之间的通信考虑，而预留的一块内存区，因此共享内存是以传输数据为目的
- 共享内存允许两个或多个进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其他进程都会察觉到这个更改
- 共享内存无同步无互斥

### shmget（）创建共享内存函数

`int shmget(key_t key,size_t size,int shmflg);`

### shmat（）映射函数

如果一个进程想要访问这个共享内存，那么需要将其映射到进程的虚拟空间中，然后再访问它。

`void *shmat(int shmid,const void *shmaddr,int shmflg);`

- shmaddr:如果不为NULL，则系统会根据shmaddr来选择一个合适的内存区域，如果为NULL，则系统会自动选择一个合适的虚拟内存空间地址去映射共享内存。
- shmflg：操作共享内存的方式：
  - SHM_RDONLY：以只读方式映射共享内存。
  - SHM_REMAP：重新映射，此时shmaddr不能为NULL。
  - NULLSHM：自动选择比shmaddr小的最大页对齐地址。
- return： 返回共享内存的起始地址

**ATTENTION**

- 共享内存只能以只读 或者只读写的方式映射，无法一只写的方式映射

### shmdt（）解除映射函数

解除进程与共享内存之间的映射，在解除映射之后，进程不能再访问这个共享内存

`int shmdt(const void *shmaddr);`

- return：成功0；失败-1，并将错误号存放于errno中

**ATTENTION**

只是将shamt（）映射好的共享内存脱离当前进程，共享内存还是存在于物理内存中

### shmctl（） 获取或设置属性函数

`int shmctl(int shmid,int cmd,struct shmid_ds *buf)`

- cmd: IPC_STAT：获取属性信息，放置到buf中。

  ​		  IPC_SET：设置属性信息为buf指向的内容。

  ​          IPC_RMID：删除这该共享内存。