### ”三次握手“建立连接

建立连接的过程时有客户端发起的，服务端无时无刻都在等待着客户端的连接。

<img src="F:\A_Sources\A笔记整理\图片\三次握手.png" style="zoom:60%;" />

- 客户端的TCP先向服务端的TCP发送一个特殊的TCP报文段，该报文段中不包含应用层的数据，但是在报文段的首部种的SYN标志位会被置1——特殊的报文段被称为SYN报文段。另外客户会随机的选择一个初始序号（ISN，假设为A），并将此序号放置于该SYN报文段的序号字段中，但SYN报文段中的ACK标志位为0，此时她的确认序号段是无效的。该报文段会被封装在一个IP数据报中，然后发送给目标服务器。
- 一旦服务器收到了客户端发出的SYN报文段，服务器便会从SYN报文段中提取对应的信息，为该TCP连接分配YTCP缓存和变量，并向该客户TCP发送允许连接的报文段（握手应答报文）。这个报文段同样不包含任何应用层数据名单时报文段的首部包含3个重要信息：

1. SYN与ACK标志都被置为1
2. 将TCP报文段首部的确认序号字段设置为A+1（这个A（ISN）是从握手请求报文中得到）
3. 服务器随机选择自己的初始序号（ISN，注意此ISN是服务器端的ISN，假设为B），并将其放置到TCP报文段首部的序号字段中

- 当客户端收到服务器的握手应答报文后，会将ACK标志置位，此时客户端的TCP报文段的 ACK标志被设置为1，而对于SYN标志，因为连接已经建立了，所以该标志会被置为0，同时客户端也要给该TCP连接分配缓存和变量，并且客户端还需要返回一个应答报文段，这个报文对服务器的应答报文段作出应答，将TCP报文段首部的确认序号字段设置为B+1，同时也会告知服务器的窗口大小。

  ***第三个阶段可以在报文段数据区域携带客户到服务器的数据***

完成握手后，客户端与服务器就建立了连接，同时双方都得到了彼此的窗口大小，序列号等信息，在传输TCP报文段的时候，每个TCP报文段首部的SYN标志都会被置0，因为它只用于发起连接，同步序号

### “四次挥手”终止连接

建立一个连接需要三次握手，而终止一个连接要经过四次挥手。这是由于TCP的特性造成的，TCp是全双工连接的服务，每个方向上的连接必须单独关闭。当一端完成它的数据发送任务后就能发送一个FIN报文段（终止连接请求，FIN标志位置为1）来终止这个方向上的连接。另一端收到一个FIN报文段，它必须通知应用层对方已经终止了那个方向的连接，发送FIN报文段通常是应用层进行关闭的结果。



<img src="F:\A_Sources\A笔记整理\图片\四次挥手.png" style="zoom:80%;" />

1.客户端发出一个FIN报文段主动进行关闭连接，此时报文段的FIN标志位为1，假设序号为C。一般来说ACK标志也会被置一，但确认序号字段是无效的。

2.当服务器收到这个 FIN报文段，它发回一个ACK报文段（此报文段是终止连接应答），确认序号为收到的序号加 1（C+1），和SYN一样，一个FIN将占用一个序号，此时断开客户端->服务器的方向连接。

3.服务器会向应用程序请求关闭与这个客户端的连接，接着服务器就会发送一个FIN报文段（这个报文段是服务器向客户端发出，请求终止连接），此时假设序号为D，ACK标志虽然也为1，但是确认序号字段是无效的。

4.客户端返回一个ACK报文段来确认终止连接的请求，ACK标志置一，并将确认序号设置为收到序号加1（D+1），此时断开服务器->客户端的方向连接。

### TCP状态 

TCP协议根据连接时收到报文的不同类型，采取相应的动作，还要处理各个状态的关系

收到握手报文、超时、用户主动关闭的时候都需要不一样的状态去采取不一样的处理



- LISTENING状态：提供某种服务，侦听TCP端口的连接请求，当提供的服务没有被连接时，处于LISTENING状态，端口开放，等待被连接
- SYN_SENT（客户端状态）：客户端调用connect()函数，发送一个SYN请求建立一个连接，在发送连接后等待匹配的连接请求，此状态为SYN_SENT
- SYS_RECEIVE(服务端状态)：当服务端收到客户端发送的同步信号后，将标志位ACK和SYN置1发送给客户端，此时服务器端处于SYN_RCVD的状态，如果连接成功了就变为ESTABLISHED，正常状态下此状态非常短
- ESTABLISHED状态：此状态是处于稳定连接状态，建立连接的TCP协议两端主机都处于这个状态，它们相互知道彼此的窗口大小、序列号、最大报文段等信息
- FIN_WAIT1与FIN_WAIT2状态：单向请求终止连接，主机等待对方回应，如果对方产生应答，主机状态转为FIN_WAIT2，此时**主机->对方**方向的TCP连接就已经断开。但是**对方->主机**方向的连接还是存在的。如果主机处于FIN_WAIT2的状态，说明主机已经发送FIN信号，并且对方也已经确认，此时在等待对方主机的应用层处理关闭连接。只有当另一端的进程完成这个关闭，主机这端才会从FIN_WAIT2状态进入TIME_WAIT状态。
- CLOSE_WAIT状态：等待从本地用户发来的连接中断请求，被动关闭端TCP接到FIN后，就发出ACK回应FIN请求（接受也会作为文件描述符 传递给上层应用程序）并进入CLOSE_WAIT状态
- TIME_WAIT状态：也称为**2MSL等待状态**，每个具体TCP连接的实现必须选择一个TCP报文段最大生存时间MSL（Maximum Segment Lifetime），如IP数据报中的TTL字段，表示报文在网络中生存的时间，它是任何报文段被丢弃前在网络内的最长时间。

<img src="F:\A_Sources\A笔记整理\图片\TCP状态转换.png" style="zoom:80%;" />

- 虚线：表示服务器的状态转移
- 实现：客户端的状态转移
- 所有“关闭”、“打开”都是应用程序主动处理
- 途中“超时“都是内核超时处理

![](F:\A_Sources\A笔记整理\图片\三次握手1.png)

![](F:\A_Sources\A笔记整理\图片\四次挥手1.png)